package com.github.k1rakishou.zoomable.internal

import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.TransformOrigin
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.withTransform
import androidx.compose.ui.layout.ScaleFactor
import androidx.compose.ui.unit.IntRect
import androidx.compose.ui.unit.IntSize
import kotlin.math.absoluteValue
import kotlin.math.ceil
import kotlin.math.min
import kotlin.math.roundToInt

internal fun Size.roundToIntSize() =
  IntSize(width.roundToInt(), height.roundToInt())

internal operator fun Size.times(scale: ScaleFactor) =
  Size(
    width = width * scale.scaleX,
    height = height * scale.scaleY,
  )

internal fun Size.discardFractionalParts(): IntSize {
  return IntSize(width = width.toInt(), height = height.toInt())
}

internal val ScaleFactor.maxScale: Float
  get() = maxOf(scaleX, scaleY)

internal operator fun ScaleFactor.unaryMinus(): ScaleFactor =
  this * -1f

internal val ScaleFactor.Companion.Zero
  get() = ScaleFactor(0f, 0f)

internal val TransformOrigin.Companion.Zero
  get() = TransformOrigin(0f, 0f)

internal operator fun Offset.times(factor: ScaleFactor) =
  Offset(x = x * factor.scaleX, y = y * factor.scaleY)

internal operator fun Offset.div(factor: ScaleFactor) =
  Offset(x = x / factor.scaleX, y = y / factor.scaleY)

/**
 * Call [action] with [zoom] and [translate] applied to this offset. The value
 * generated by [action] is returned by applying the inverse of [translate] of [zoom].
 *
 * The name of this function was inspired from [DrawScope.withTransform].
 */
internal fun Offset.withZoomAndTranslate(
  zoom: ScaleFactor,
  translate: Offset,
  action: (Offset) -> Offset,
): Offset {
  return (action((this * zoom) + translate) - translate) / zoom
}


internal fun Size.coerceAtLeast(other: IntSize): Size {
  return Size(
    width = width.coerceAtLeast(other.width.toFloat()),
    height = height.coerceAtLeast(other.height.toFloat())
  )
}

internal fun IntSize.coerceAtMost(other: IntSize): IntSize {
  return IntSize(
    width = width.coerceAtMost(other.width),
    height = height.coerceAtMost(other.height)
  )
}

internal val IntSize.minDimension: Int
  get() = min(width.absoluteValue, height.absoluteValue)

internal fun Float.toCeilInt(): Int {
  return ceil(this).toInt()
}

internal fun IntRect.scaledAndOffsetBy(scale: ScaleFactor, offset: Offset): Rect {
  return Rect(
    left = (left * scale.scaleX) + offset.x,
    right = (right * scale.scaleX) + offset.x,
    top = (top * scale.scaleY) + offset.y,
    bottom = (bottom * scale.scaleY) + offset.y,
  )
}

internal fun Rect.discardFractionalValues(): IntRect {
  return IntRect(
    left = left.toInt(),
    right = right.toInt(),
    top = top.toInt(),
    bottom = bottom.toInt(),
  )
}

/**
 * Equivalent to `Rect#overlaps(Rect(Offset.Zero, size))`.
 *
 * Copied from [Rect.overlaps]
 */
internal fun Rect.overlaps(other: IntSize): Boolean {
  if (right <= 0 || other.width <= left)
    return false
  if (bottom <= 0 || other.height <= top)
    return false
  return true
}

